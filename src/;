//#![allow(unused_imports)]
extern crate anyhow;
#[macro_use] extern crate tracing;
extern crate clap_verbosity_flag as cvf;
extern crate tracing_subscriber;
use tracing_subscriber::{prelude::*, fmt::{self, time}};
extern crate clap;
use clap::Parser;
extern crate tokio;
extern crate base64;
extern crate blake3;
extern crate url;
#[macro_use] extern crate lazy_static;
extern crate sled;
extern crate tower;
use tower::{steer::Steer, util::BoxService, service_fn, ServiceFn};
extern crate tower_http;
use tower_http::services::ServeDir;
use std::{sync::Arc, future::Future};
extern crate directories;
extern crate quinn;
extern crate rcgen;
extern crate rustls;
use anyhow::Result;
use http::{Request,Response,StatusCode,Method};
pub mod util;
use util::*;
pub mod handlers;
use handlers::*;
pub mod transport;
use std::net::SocketAddr;
#[cfg(feature="axum")]
extern crate axum;
#[cfg(feature="axum")]
use axum::{Router, routing::{get, get_service}};

lazy_static! {
    pub static ref ENCODED_LEN: usize = {
        let cli = Cli::parse();
        cli.length
    };
}


#[cfg(feature = "axum")]
async fn run_axum(cli: Cli, db: Arc<sled::Db>) -> Result<()> {
    let state = AppState { db, hostname: cli.hostname.clone(), port: cli.port };
    let app = Router::new()
        .route("/", get(root).post(accept_form))
        .route("/:key", get(redirect))
        .nest_service("/assets", get_service(ServeDir::new("./assets")))
        .with_state(state);
    let addr = SocketAddr::new(cli.address, cli.port);
    let listener = tokio::net::TcpListener::bind(addr).await?;
    debug!("Listening on {}", listener.local_addr()?);
    tokio::select! {
        res = axum::serve(listener, app) => {
            match res {
                Ok(_) => debug!("Serve task completed without error."),
                Err(e) => error!("Serve task exited with error: {:?}", e),
            }
        },
        _ = tokio::signal::ctrl_c() => {
            warn!("ctrl-c signal received, shutting down gracefully.");
        }
    }
    Ok(())
}

fn box_svcfn<T,U,E,R,F>(f: T) -> BoxService<T,U,E>
where
    T: Send + FnMut(R) -> F,
    F: Send + Future<Output = Result<R,E>>,
    R: Send,
    E: Send
{
    let svc_fn = service_fn(f);
    BoxService::new(svc_fn)
}

async fn run_h3(cli: Cli, db: Arc<sled::Db>) -> Result<()> {
    let root = box_svcfn(handlers::root);
        /*
    let mut svc = Steer::new(
        vec![root]
        );
        */
    let endpoint = transport::make_server_endpoint(&cli)?;
    Ok(())
}

#[tokio::main]
async fn run(cli: Cli) -> Result<()> {
    let db = Arc::new(sled::open(&cli.db)?);
    info!("Opened database at {}", cli.db);
    let res = {
        #[cfg(feature = "axum")]
        run_axum(cli, db.clone())
    }.await?;
    
    let bytes_flushed = db.flush()?;
    debug!("Flushed {} bytes to disk", bytes_flushed);
    Ok(())
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    let fmt_layer = {
        let layer = fmt::layer()
            .with_thread_ids(true)
            .with_thread_names(true)
            .with_line_number(true)
            .with_file(true)
            .with_timer(time::uptime());
        if cli.compact {
            layer.compact().boxed()
        }
        else if cli.pretty {
            layer.pretty().boxed()
        }
        else {
            layer.boxed()
        }
    }
    .with_filter(verbosity_to_level(cli.verbose.log_level().unwrap_or_else(|| cvf::Level::Info)));
    let subscriber = tracing_subscriber::registry()
        .with(fmt_layer);
    tracing::subscriber::set_global_default(subscriber).expect("Failed to set tracing subscriber.");
    info!("Initialized logger.");
    run(cli).map_err(|e| { error!("{}",e); e})?;
    Ok(())
}

